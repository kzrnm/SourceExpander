using System.Threading.Tasks;
using Microsoft.CodeAnalysis.Testing;
using Xunit;

namespace SourceExpander.Generate
{
    public class ComplicatedDependenciesTest : ExpandGeneratorTestBase
    {
        [Fact]
        public async Task Generate()
        {
            var test = new Test
            {
                ReferenceAssemblies = ReferenceAssemblies.Net.Net50
                    .AddPackages(Packages.Add(new PackageIdentity("ac-library-csharp", "1.4.4"))),
                TestState =
                {
                    Sources = {
                        (
                            @"/home/mine/Program.cs",
                            @"
using System;
using System.Linq;
using AtCoder;
using static AtCoder.MathLib;
using ModInt = AtCoder.StaticModInt<AtCoder.Mod998244353>;
namespace Solvers
{
    public class ConvolutionSolver
    {
        public void Solve()
        {
            int n = int.Parse(Console.ReadLine());
            int m = int.Parse(Console.ReadLine());
            var a = Console.ReadLine().Split(' ').Select(int.Parse).Select(ModInt.Raw).ToArray();
            var b = Console.ReadLine().Split(' ').Select(int.Parse).Select(ModInt.Raw).ToArray();
            var c = Convolution(a, b);
            var seg = new Segtree<ModInt, ModIntOp>(c);
            Console.WriteLine(seg.AllProd);
        }
    }
    struct ModIntOp : ISegtreeOperator<ModInt>
    {
        public ModInt Operate(ModInt x, ModInt y) => x * y;
        public ModInt Identity => 1;
    }
}
"
                        ),
                    },
                    GeneratedSources =
                    {
                        (typeof(ExpandGenerator), "SourceExpander.Expanded.cs", (@"using System.Collections.Generic;
namespace SourceExpander.Expanded{
public static class ExpandedContainer{
public static IReadOnlyDictionary<string, SourceCode> Files {get{ return _Files; }}
private static Dictionary<string, SourceCode> _Files = new Dictionary<string, SourceCode>{
{""/home/mine/Program.cs"",SourceCode.FromDictionary(new Dictionary<string,object>{{""path"",""/home/mine/Program.cs""},{""code"","
+ @"using AtCoder;
using AtCoder.Internal;
using ModInt = AtCoder.StaticModInt<AtCoder.Mod998244353>;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics.X86;
using static AtCoder.MathLib;
namespace Solvers
{
    public class ConvolutionSolver
    {
        public void Solve()
        {
            int n = int.Parse(Console.ReadLine());
            int m = int.Parse(Console.ReadLine());
            var a = Console.ReadLine().Split(' ').Select(int.Parse).Select(ModInt.Raw).ToArray();
            var b = Console.ReadLine().Split(' ').Select(int.Parse).Select(ModInt.Raw).ToArray();
            var c = Convolution(a, b);
            var seg = new Segtree<ModInt, ModIntOp>(c);
            Console.WriteLine(seg.AllProd);
        }
    }
    struct ModIntOp : ISegtreeOperator<ModInt>
    {
        public ModInt Operate(ModInt x, ModInt y) => x * y;
        public ModInt Identity => 1;
    }
}
#region Expanded by https://github.com/kzrnm/SourceExpander
namespace AtCoder{public interface ISegtreeOperator<T>{T Identity{get;}T Operate(T x,T y);}public class Segtree<TValue,TOp>where TOp:struct,ISegtreeOperator<TValue>{private static readonly TOp op=default;public int Length{get;}internal readonly int log;internal readonly int size;public readonly TValue[]d;public Segtree(int n){Length=n;log=InternalBit.CeilPow2(n);size=1<<log;d=new TValue[2*size];Array.Fill(d,op.Identity);}public Segtree(TValue[]v):this(v.Length){for(int i=0;i<v.Length;i++)d[size+i]=v[i];for(int i=size-1;i>=1;i--){Update(i);}}[MethodImpl(MethodImplOptions.AggressiveInlining)]public void Update(int k)=>d[k]=op.Operate(d[2*k],d[2*k+1]);public TValue this[int p]{[MethodImpl(MethodImplOptions.AggressiveInlining)]set{p+=size;d[p]=value;for(int i=1;i<=log;i++)Update(p>>i);}[MethodImpl(MethodImplOptions.AggressiveInlining)]get{return d[p+size];}}[MethodImpl(MethodImplOptions.AggressiveInlining)]public TValue Slice(int l,int len)=>Prod(l,l+len);[MethodImpl(MethodImplOptions.AggressiveInlining)]public TValue Prod(int l,int r){TValue sml=op.Identity,smr=op.Identity;l+=size;r+=size;while(l<r){if((l&1)!=0)sml=op.Operate(sml,d[l++]);if((r&1)!=0)smr=op.Operate(d[ --r],smr);l>>=1;r>>=1;}return op.Operate(sml,smr);}public TValue AllProd=>d[1];public int MaxRight(int l,Predicate<TValue>f){if(l==Length)return Length;l+=size;var sm=op.Identity;do{while(l%2==0)l>>=1;if(!f(op.Operate(sm,d[l]))){while(l<size){l=(2*l);if(f(op.Operate(sm,d[l]))){sm=op.Operate(sm,d[l]);l++;}}return l-size;}sm=op.Operate(sm,d[l]);l++;}while((l&-l)!=l);return Length;}public int MinLeft(int r,Predicate<TValue>f){if(r==0)return 0;r+=size;var sm=op.Identity;do{r--;while(r>1&&(r%2)!=0)r>>=1;if(!f(op.Operate(d[r],sm))){while(r<size){r=(2*r+1);if(f(op.Operate(d[r],sm))){sm=op.Operate(d[r],sm);r--;}}return r+1-size;}sm=op.Operate(d[r],sm);}while((r&-r)!=r);return 0;}private struct DebugItem{public DebugItem(int l,int r,TValue value){if(r-l==1)key=$""[{l}]"";else key=$""[{l}-{r})"";this.value=value;}private readonly string key;private readonly TValue value;}private class DebugView{private readonly Segtree<TValue,TOp>segtree;public DebugView(Segtree<TValue,TOp>segtree){this.segtree=segtree;}public DebugItem[]Items{get{var items=new SimpleList<DebugItem>(segtree.Length);for(int len=segtree.size;len>0;len>>=1){int unit=segtree.size/len;for(int i=0;i<len;i++){int l=i*unit;int r=Math.Min(l+unit,segtree.Length);if(l<segtree.Length)items.Add(new DebugItem(l,r,segtree.d[i+len]));}}return items.ToArray();}}}}}
namespace AtCoder.Internal{using static MethodImplOptions;public static class InternalBit{[MethodImpl(AggressiveInlining)]public static int ExtractLowestSetBit(int n){if(Bmi1.IsSupported){return(int)Bmi1.ExtractLowestSetBit((uint)n);}return n&-n;}[MethodImpl(AggressiveInlining)]public static int BSF(uint n){return BitOperations.TrailingZeroCount(n);}[MethodImpl(AggressiveInlining)]public static int CeilPow2(int n){var un=(uint)n;if(un<=1)return 0;return BitOperations.Log2(un-1)+1;}}}
namespace AtCoder.Internal{public class SimpleList<T>:IList<T>,IReadOnlyList<T>{private T[]data;private const int DefaultCapacity=2;public SimpleList(){data=new T[DefaultCapacity];}public SimpleList(int capacity){data=new T[Math.Max(capacity,DefaultCapacity)];}public SimpleList(IEnumerable<T>collection){if(collection is ICollection<T>col){data=new T[col.Count];col.CopyTo(data,0);Count=col.Count;}else{data=new T[DefaultCapacity];foreach(var item in collection)Add(item);}}public Span<T>AsSpan()=>new Span<T>(data,0,Count);public ref T this[int index]{[MethodImpl(MethodImplOptions.AggressiveInlining)]get{if((uint)index>=(uint)Count)ThrowIndexOutOfRangeException();return ref data[index];}}public int Count{get;private set;}public void Add(T item){if((uint)Count>=(uint)data.Length)Array.Resize(ref data,data.Length<<1);data[Count++]=item;}public void RemoveLast(){if( --Count<0)ThrowIndexOutOfRangeException();}public SimpleList<T>Reverse(){Array.Reverse(data,0,Count);return this;}public SimpleList<T>Reverse(int index,int count){Array.Reverse(data,index,count);return this;}public SimpleList<T>Sort(){Array.Sort(data,0,Count);return this;}public SimpleList<T>Sort(IComparer<T>comparer){Array.Sort(data,0,Count,comparer);return this;}public SimpleList<T>Sort(int index,int count,IComparer<T>comparer){Array.Sort(data,index,count,comparer);return this;}public void Clear()=>Count=0;public bool Contains(T item)=>IndexOf(item)>=0;public int IndexOf(T item)=>Array.IndexOf(data,item,0,Count);public void CopyTo(T[]array,int arrayIndex)=>Array.Copy(data,0,array,arrayIndex,Count);public T[]ToArray()=>AsSpan().ToArray();bool ICollection<T>.IsReadOnly=>false;T IList<T>.this[int index]{get=>data[index];set=>data[index]=value;}T IReadOnlyList<T>.this[int index]{get=>data[index];}void IList<T>.Insert(int index,T item)=>throw new NotSupportedException();bool ICollection<T>.Remove(T item)=>throw new NotSupportedException();void IList<T>.RemoveAt(int index)=>throw new NotSupportedException();IEnumerator IEnumerable.GetEnumerator()=>((IEnumerable<T>)this).GetEnumerator();IEnumerator<T>IEnumerable<T>.GetEnumerator(){for(int i=0;i<Count;i++)yield return data[i];}public Span<T>.Enumerator GetEnumerator()=>AsSpan().GetEnumerator();private static void ThrowIndexOutOfRangeException()=>throw new IndexOutOfRangeException();}}
namespace AtCoder.Internal{public class Barrett{public uint Mod{get;private set;}internal readonly ulong IM;public Barrett(uint m){Mod=m;IM=unchecked((ulong)-1)/m+1;}public uint Mul(uint a,uint b){ulong z=a;z*=b;if(Bmi2.X64.IsSupported){var x=Bmi2.X64.MultiplyNoFlags(z,IM);var v=unchecked((uint)(z-x*Mod));if(Mod<=v)v+=Mod;return v;}return(uint)(z%Mod);}}}
namespace AtCoder.Internal{public static class Butterfly<T>where T:struct,IStaticMod{internal static readonly StaticModInt<T>[]sumE=CalcurateSumE();internal static readonly StaticModInt<T>[]sumIE=CalcurateSumIE();[MethodImpl(MethodImplOptions.AggressiveOptimization)]public static void Calculate(Span<StaticModInt<T>>a){var n=a.Length;var h=InternalBit.CeilPow2(n);var regLength=Vector<uint>.Count;var modV=new Vector<uint>(default(T).Mod);for(int ph=1;ph<=h;ph++){int w=1<<(ph-1);int p=1<<(h-ph);var now=StaticModInt<T>.Raw(1);for(int s=0;s<w;s++){int offset=s<<(h-ph+1);var ls=a.Slice(offset,p);var rs=a.Slice(offset+p,p);if(p<regLength){for(int i=0;i<p;i++){var l=ls[i];var r=rs[i]*now;ls[i]=l+r;rs[i]=l-r;}}else{foreach(ref var r in rs){r*=now;}var lu=MemoryMarshal.Cast<StaticModInt<T>,uint>(ls);var ru=MemoryMarshal.Cast<StaticModInt<T>,uint>(rs);for(int i=0;i<lu.Length;i+=regLength){var luSliced=lu.Slice(i);var ruSliced=ru.Slice(i);var u=new Vector<uint>(luSliced);var v=new Vector<uint>(ruSliced);var add=u+v;var sub=u-v;var ge=Vector.GreaterThanOrEqual(add,modV);add=Vector.ConditionalSelect(ge,add-modV,add);ge=Vector.GreaterThanOrEqual(sub,modV);sub=Vector.ConditionalSelect(ge,sub+modV,sub);add.CopyTo(luSliced);sub.CopyTo(ruSliced);}}now*=sumE[InternalBit.BSF(~(uint)s)];}}}[MethodImpl(MethodImplOptions.AggressiveOptimization)]public static void CalculateInv(Span<StaticModInt<T>>a){var n=a.Length;var h=InternalBit.CeilPow2(n);var regLength=Vector<uint>.Count;var modV=new Vector<uint>(default(T).Mod);for(int ph=h;ph>=1;ph--){int w=1<<(ph-1);int p=1<<(h-ph);var iNow=StaticModInt<T>.Raw(1);for(int s=0;s<w;s++){int offset=s<<(h-ph+1);var ls=a.Slice(offset,p);var rs=a.Slice(offset+p,p);if(p<regLength){for(int i=0;i<p;i++){var l=ls[i];var r=rs[i];ls[i]=l+r;rs[i]=StaticModInt<T>.Raw((int)((ulong)(default(T).Mod+l.Value-r.Value)*(ulong)iNow.Value%default(T).Mod));}}else{var lu=MemoryMarshal.Cast<StaticModInt<T>,uint>(ls);var ru=MemoryMarshal.Cast<StaticModInt<T>,uint>(rs);for(int i=0;i<lu.Length;i+=regLength){var luSliced=lu.Slice(i);var ruSliced=ru.Slice(i);var u=new Vector<uint>(luSliced);var v=new Vector<uint>(ruSliced);var add=u+v;var sub=u-v;var ge=Vector.GreaterThanOrEqual(add,modV);add=Vector.ConditionalSelect(ge,add-modV,add);sub+=modV;add.CopyTo(luSliced);sub.CopyTo(ruSliced);}foreach(ref var r in rs){r*=iNow;}}iNow*=sumIE[InternalBit.BSF(~(uint)s)];}}}private static StaticModInt<T>[]CalcurateSumE(){int g=InternalMath.PrimitiveRoot((int)default(T).Mod);int cnt2=InternalBit.BSF(default(T).Mod-1);var e=new StaticModInt<T>(g).Pow((default(T).Mod-1)>>cnt2);var ie=e.Inv();var sumE=new StaticModInt<T>[30];Span<StaticModInt<T>>es=stackalloc StaticModInt<T>[cnt2-1];Span<StaticModInt<T>>ies=stackalloc StaticModInt<T>[cnt2-1];for(int i=es.Length-1;i>=0;i--){es[i]=e;ies[i]=ie;e*=e;ie*=ie;}var now=StaticModInt<T>.Raw(1);for(int i=0;i<=cnt2-2;i++){sumE[i]=es[i]*now;now*=ies[i];}return sumE;}private static StaticModInt<T>[]CalcurateSumIE(){int g=InternalMath.PrimitiveRoot((int)default(T).Mod);int cnt2=InternalBit.BSF(default(T).Mod-1);var e=new StaticModInt<T>(g).Pow((default(T).Mod-1)>>cnt2);var ie=e.Inv();var sumIE=new StaticModInt<T>[30];Span<StaticModInt<T>>es=stackalloc StaticModInt<T>[cnt2-1];Span<StaticModInt<T>>ies=stackalloc StaticModInt<T>[cnt2-1];for(int i=es.Length-1;i>=0;i--){es[i]=e;ies[i]=ie;e*=e;ie*=ie;}var now=StaticModInt<T>.Raw(1);for(int i=0;i<=cnt2-2;i++){sumIE[i]=ies[i]*now;now*=es[i];}return sumIE;}[Conditional(""ATCODER_CONTRACT"")]private static void CheckPow2(int n){if(BitOperations.PopCount((uint)n)!=1){throw new ArgumentException(""配列長は2のべき乗でなければなりません。"");}}}}
namespace AtCoder.Internal{public static partial class InternalMath{private static readonly Dictionary<int,int>primitiveRootsCache=new Dictionary<int,int>(){{2,1},{167772161,3},{469762049,3},{754974721,11},{998244353,3}};public static int PrimitiveRoot(int m){if(primitiveRootsCache.TryGetValue(m,out var p)){return p;}return primitiveRootsCache[m]=PrimitiveRootCalculate(m);}static int PrimitiveRootCalculate(int m){Span<int>divs=stackalloc int[20];divs[0]=2;int cnt=1;int x=(m-1)/2;while(x%2==0){x>>=1;}for(int i=3;(long)i*i<=x;i+=2){if(x%i==0){divs[cnt++]=i;while(x%i==0){x/=i;}}}if(x>1){divs[cnt++]=x;}for(int g=2;;g++){bool ok=true;for(int i=0;i<cnt;i++){if(MathLib.PowMod(g,(m-1)/divs[i],m)==1){ok=false;break;}}if(ok){return g;}}}public static(long,long)InvGCD(long a,long b){a=SafeMod(a,b);if(a==0)return(b,0);long s=b,t=a;long m0=0,m1=1;long u;while(true){if(t==0){if(m0<0)m0+=b/s;return(s,m0);}u=s/t;s-=t*u;m0-=m1*u;if(s==0){if(m1<0)m1+=b/t;return(t,m1);}u=t/s;t-=s*u;m1-=m0*u;}}public static long SafeMod(long x,long m){x%=m;if(x<0)x+=m;return x;}public static bool IsPrime(int n){if(n<=1)return false;if(n==2||n==7||n==61)return true;if(n%2==0)return false;long d=n-1;while(d%2==0)d/=2;ReadOnlySpan<long>bases=stackalloc long[3]{2,7,61};foreach(long a in bases){long t=d;long y=MathLib.PowMod(a,t,n);while(t!=n-1&&y!=1&&y!=n-1){y=y*y%n;t<<=1;}if(y!=n-1&&t%2==0){return false;}}return true;}}}
namespace AtCoder{public static class MathLib{public static int[]Convolution(int[]a,int[]b)=>Convolution<Mod998244353>(a,b);public static uint[]Convolution(uint[]a,uint[]b)=>Convolution<Mod998244353>(a,b);public static long[]Convolution(long[]a,long[]b)=>Convolution<Mod998244353>(a,b);public static ulong[]Convolution(ulong[]a,ulong[]b)=>Convolution<Mod998244353>(a,b);public static int[]Convolution<TMod>(int[]a,int[]b)where TMod:struct,IStaticMod{var n=a.Length;var m=b.Length;if(n==0||m==0){return Array.Empty<int>();}if(Math.Min(n,m)<=60){var c=ConvolutionNaive<TMod>(a.Select(ai=>new StaticModInt<TMod>(ai)).ToArray(),b.Select(bi=>new StaticModInt<TMod>(bi)).ToArray());return c.Select(ci=>ci.Value).ToArray();}else{int z=1<<InternalBit.CeilPow2(n+m-1);var aTemp=new StaticModInt<TMod>[z];for(int i=0;i<a.Length;i++){aTemp[i]=new StaticModInt<TMod>(a[i]);}var bTemp=new StaticModInt<TMod>[z];for(int i=0;i<b.Length;i++){bTemp[i]=new StaticModInt<TMod>(b[i]);}var c=Convolution<TMod>(aTemp,bTemp,n,m,z).Slice(0,n+m-1);var result=new int[c.Length];for(int i=0;i<result.Length;i++){result[i]=c[i].Value;}return result;}}public static uint[]Convolution<TMod>(uint[]a,uint[]b)where TMod:struct,IStaticMod{var n=a.Length;var m=b.Length;if(n==0||m==0){return Array.Empty<uint>();}if(Math.Min(n,m)<=60){var c=ConvolutionNaive<TMod>(a.Select(ai=>new StaticModInt<TMod>(ai)).ToArray(),b.Select(bi=>new StaticModInt<TMod>(bi)).ToArray());return c.Select(ci=>(uint)ci.Value).ToArray();}else{int z=1<<InternalBit.CeilPow2(n+m-1);var aTemp=new StaticModInt<TMod>[z];for(int i=0;i<a.Length;i++){aTemp[i]=new StaticModInt<TMod>(a[i]);}var bTemp=new StaticModInt<TMod>[z];for(int i=0;i<b.Length;i++){bTemp[i]=new StaticModInt<TMod>(b[i]);}var c=Convolution<TMod>(aTemp,bTemp,n,m,z).Slice(0,n+m-1);var result=new uint[c.Length];for(int i=0;i<result.Length;i++){result[i]=(uint)c[i].Value;}return result;}}public static long[]Convolution<TMod>(long[]a,long[]b)where TMod:struct,IStaticMod{var n=a.Length;var m=b.Length;if(n==0||m==0){return Array.Empty<long>();}if(Math.Min(n,m)<=60){var c=ConvolutionNaive<TMod>(a.Select(ai=>new StaticModInt<TMod>(ai)).ToArray(),b.Select(bi=>new StaticModInt<TMod>(bi)).ToArray());return c.Select(ci=>(long)ci.Value).ToArray();}else{int z=1<<InternalBit.CeilPow2(n+m-1);var aTemp=new StaticModInt<TMod>[z];for(int i=0;i<a.Length;i++){aTemp[i]=new StaticModInt<TMod>(a[i]);}var bTemp=new StaticModInt<TMod>[z];for(int i=0;i<b.Length;i++){bTemp[i]=new StaticModInt<TMod>(b[i]);}var c=Convolution<TMod>(aTemp,bTemp,n,m,z).Slice(0,n+m-1);var result=new long[c.Length];for(int i=0;i<result.Length;i++){result[i]=c[i].Value;}return result;}}public static ulong[]Convolution<TMod>(ulong[]a,ulong[]b)where TMod:struct,IStaticMod{var n=a.Length;var m=b.Length;if(n==0||m==0){return Array.Empty<ulong>();}if(Math.Min(n,m)<=60){Func<ulong,StaticModInt<TMod>>takeMod=x=>StaticModInt<TMod>.Raw((int)(x%default(TMod).Mod));var c=ConvolutionNaive<TMod>(a.Select(takeMod).ToArray(),b.Select(takeMod).ToArray());return c.Select(ci=>(ulong)ci.Value).ToArray();}else{int z=1<<InternalBit.CeilPow2(n+m-1);var aTemp=new StaticModInt<TMod>[z];for(int i=0;i<a.Length;i++){aTemp[i]=StaticModInt<TMod>.Raw((int)(a[i]%default(TMod).Mod));}var bTemp=new StaticModInt<TMod>[z];for(int i=0;i<b.Length;i++){bTemp[i]=StaticModInt<TMod>.Raw((int)(b[i]%default(TMod).Mod));}var c=Convolution<TMod>(aTemp,bTemp,n,m,z).Slice(0,n+m-1);var result=new ulong[c.Length];for(int i=0;i<result.Length;i++){result[i]=(ulong)c[i].Value;}return result;}}public static StaticModInt<TMod>[]Convolution<TMod>(StaticModInt<TMod>[]a,StaticModInt<TMod>[]b)where TMod:struct,IStaticMod{var temp=Convolution((ReadOnlySpan<StaticModInt<TMod>>)a,b);return temp.ToArray();}public static Span<StaticModInt<TMod>>Convolution<TMod>(ReadOnlySpan<StaticModInt<TMod>>a,ReadOnlySpan<StaticModInt<TMod>>b)where TMod:struct,IStaticMod{var n=a.Length;var m=b.Length;if(n==0||m==0){return Array.Empty<StaticModInt<TMod>>();}if(Math.Min(n,m)<=60){return ConvolutionNaive(a,b);}int z=1<<InternalBit.CeilPow2(n+m-1);var aTemp=new StaticModInt<TMod>[z];a.CopyTo(aTemp);var bTemp=new StaticModInt<TMod>[z];b.CopyTo(bTemp);return Convolution(aTemp.AsSpan(),bTemp.AsSpan(),n,m,z);}private static Span<StaticModInt<TMod>>Convolution<TMod>(Span<StaticModInt<TMod>>a,Span<StaticModInt<TMod>>b,int n,int m,int z)where TMod:struct,IStaticMod{Butterfly<TMod>.Calculate(a);Butterfly<TMod>.Calculate(b);for(int i=0;i<a.Length;i++){a[i]*=b[i];}Butterfly<TMod>.CalculateInv(a);var result=a.Slice(0,n+m-1);var iz=new StaticModInt<TMod>(z).Inv();foreach(ref var r in result){r*=iz;}return result;}public static long[]ConvolutionLong(ReadOnlySpan<long>a,ReadOnlySpan<long>b){unchecked{var n=a.Length;var m=b.Length;if(n==0||m==0){return Array.Empty<long>();}const ulong Mod1=754974721;const ulong Mod2=167772161;const ulong Mod3=469762049;const ulong M2M3=Mod2*Mod3;const ulong M1M3=Mod1*Mod3;const ulong M1M2=Mod1*Mod2;const ulong M1M2M3=Mod1*Mod2*Mod3;ulong i1=(ulong)InternalMath.InvGCD((long)M2M3,(long)Mod1).Item2;ulong i2=(ulong)InternalMath.InvGCD((long)M1M3,(long)Mod2).Item2;ulong i3=(ulong)InternalMath.InvGCD((long)M1M2,(long)Mod3).Item2;var c1=Convolution<FFTMod1>(a,b);var c2=Convolution<FFTMod2>(a,b);var c3=Convolution<FFTMod3>(a,b);var c=new long[n+m-1];Span<ulong>offset=stackalloc ulong[]{0,0,M1M2M3,2*M1M2M3,3*M1M2M3};for(int i=0;i<c.Length;i++){ulong x=0;x+=(c1[i]*i1)%Mod1*M2M3;x+=(c2[i]*i2)%Mod2*M1M3;x+=(c3[i]*i3)%Mod3*M1M2;long diff=(long)c1[i]-InternalMath.SafeMod((long)x,(long)Mod1);if(diff<0){diff+=(long)Mod1;}x-=offset[(int)(diff%offset.Length)];c[i]=(long)x;}return c;}}private static ulong[]Convolution<TMod>(ReadOnlySpan<long>a,ReadOnlySpan<long>b)where TMod:struct,IStaticMod{int z=1<<InternalBit.CeilPow2(a.Length+b.Length-1);var aTemp=new StaticModInt<TMod>[z];for(int i=0;i<a.Length;i++){aTemp[i]=new StaticModInt<TMod>(a[i]);}var bTemp=new StaticModInt<TMod>[z];for(int i=0;i<b.Length;i++){bTemp[i]=new StaticModInt<TMod>(b[i]);}var c=AtCoder.MathLib.Convolution<TMod>(aTemp,bTemp,a.Length,b.Length,z);var result=new ulong[c.Length];for(int i=0;i<result.Length;i++){result[i]=(ulong)c[i].Value;}return result;}private static StaticModInt<TMod>[]ConvolutionNaive<TMod>(ReadOnlySpan<StaticModInt<TMod>>a,ReadOnlySpan<StaticModInt<TMod>>b)where TMod:struct,IStaticMod{if(a.Length<b.Length){var temp=a;a=b;b=temp;}var ans=new StaticModInt<TMod>[a.Length+b.Length-1];for(int i=0;i<a.Length;i++){for(int j=0;j<b.Length;j++){ans[i+j]+=a[i]*b[j];}}return ans;}private readonly struct FFTMod1:IStaticMod{public uint Mod=>754974721;public bool IsPrime=>true;}private readonly struct FFTMod2:IStaticMod{public uint Mod=>167772161;public bool IsPrime=>true;}private readonly struct FFTMod3:IStaticMod{public uint Mod=>469762049;public bool IsPrime=>true;}public static long PowMod(long x,long n,int m){if(m==1)return 0;Barrett barrett=new Barrett((uint)m);uint r=1,y=(uint)InternalMath.SafeMod(x,m);while(0<n){if((n&1)!=0)r=barrett.Mul(r,y);y=barrett.Mul(y,y);n>>=1;}return r;}public static long InvMod(long x,long m){var(g,res)=InternalMath.InvGCD(x,m);return res;}public static(long y,long m)CRT(long[]r,long[]m){long r0=0,m0=1;for(int i=0;i<m.Length;i++){long r1=InternalMath.SafeMod(r[i],m[i]);long m1=m[i];if(m0<m1){(r0,r1)=(r1,r0);(m0,m1)=(m1,m0);}if(m0%m1==0){if(r0%m1!=r1)return(0,0);continue;}var(g,im)=InternalMath.InvGCD(m0,m1);long u1=(m1/g);if((r1-r0)%g!=0)return(0,0);long x=(r1-r0)/g%u1*im%u1;r0+=x*m0;m0*=u1;if(r0<0)r0+=m0;}return(r0,m0);}public static long FloorSum(long n,long m,long a,long b){long ans=0;while(true){if(a>=m){ans+=(n-1)*n*(a/m)/2;a%=m;}if(b>=m){ans+=n*(b/m);b%=m;}long yMax=(a*n+b)/m;long xMax=yMax*m-b;if(yMax==0)return ans;ans+=(n-(xMax+a-1)/a)*yMax;(n,m,a,b)=(yMax,a,m,(a-xMax%a)%a);}}}}
namespace AtCoder{using static MethodImplOptions;public interface IStaticMod{uint Mod{get;}bool IsPrime{get;}}public readonly struct Mod1000000007:IStaticMod{public uint Mod=>1000000007;public bool IsPrime=>true;}public readonly struct Mod998244353:IStaticMod{public uint Mod=>998244353;public bool IsPrime=>true;}public readonly struct StaticModIntOperator<T>:IArithmeticOperator<StaticModInt<T>>where T:struct,IStaticMod{public StaticModInt<T>MultiplyIdentity=>StaticModInt<T>.Raw(1);[MethodImpl(AggressiveInlining)]public StaticModInt<T>Add(StaticModInt<T>x,StaticModInt<T>y)=>x+y;[MethodImpl(AggressiveInlining)]public StaticModInt<T>Subtract(StaticModInt<T>x,StaticModInt<T>y)=>x-y;[MethodImpl(AggressiveInlining)]public StaticModInt<T>Multiply(StaticModInt<T>x,StaticModInt<T>y)=>x*y;[MethodImpl(AggressiveInlining)]public StaticModInt<T>Divide(StaticModInt<T>x,StaticModInt<T>y)=>x/y;[MethodImpl(AggressiveInlining)]public StaticModInt<T>Modulo(StaticModInt<T>x,StaticModInt<T>y)=>throw new NotSupportedException();[MethodImpl(AggressiveInlining)]public StaticModInt<T>Minus(StaticModInt<T>x)=>-x;[MethodImpl(AggressiveInlining)]public StaticModInt<T>Increment(StaticModInt<T>x)=> ++x;[MethodImpl(AggressiveInlining)]public StaticModInt<T>Decrement(StaticModInt<T>x)=> --x;}public readonly struct StaticModInt<T>:IEquatable<StaticModInt<T>>where T:struct,IStaticMod{internal readonly uint _v;private static readonly T op=default;public int Value=>(int)_v;public static int Mod=>(int)op.Mod;[MethodImpl(AggressiveInlining)]public static StaticModInt<T>Raw(int v){var u=unchecked((uint)v);return new StaticModInt<T>(u);}public StaticModInt(long v):this(Round(v)){}private StaticModInt(uint v)=>_v=v;[MethodImpl(AggressiveInlining)]private static uint Round(long v){var x=v%op.Mod;if(x<0){x+=op.Mod;}return(uint)x;}[MethodImpl(AggressiveInlining)]public static StaticModInt<T>operator ++(StaticModInt<T>value){var v=value._v+1;if(v==op.Mod){v=0;}return new StaticModInt<T>(v);}[MethodImpl(AggressiveInlining)]public static StaticModInt<T>operator --(StaticModInt<T>value){var v=value._v;if(v==0){v=op.Mod;}return new StaticModInt<T>(v-1);}[MethodImpl(AggressiveInlining)]public static StaticModInt<T>operator+(StaticModInt<T>lhs,StaticModInt<T>rhs){var v=lhs._v+rhs._v;if(v>=op.Mod){v-=op.Mod;}return new StaticModInt<T>(v);}[MethodImpl(AggressiveInlining)]public static StaticModInt<T>operator-(StaticModInt<T>lhs,StaticModInt<T>rhs){unchecked{var v=lhs._v-rhs._v;if(v>=op.Mod){v+=op.Mod;}return new StaticModInt<T>(v);}}[MethodImpl(AggressiveInlining)]public static StaticModInt<T>operator*(StaticModInt<T>lhs,StaticModInt<T>rhs){return new StaticModInt<T>((uint)((ulong)lhs._v*rhs._v%op.Mod));}public static StaticModInt<T>operator/(StaticModInt<T>lhs,StaticModInt<T>rhs)=>lhs*rhs.Inv();public static StaticModInt<T>operator+(StaticModInt<T>value)=>value;public static StaticModInt<T>operator-(StaticModInt<T>value)=>new StaticModInt<T>(op.Mod-value._v);public static bool operator==(StaticModInt<T>lhs,StaticModInt<T>rhs)=>lhs._v==rhs._v;public static bool operator!=(StaticModInt<T>lhs,StaticModInt<T>rhs)=>lhs._v!=rhs._v;public static implicit operator StaticModInt<T>(int value)=>new StaticModInt<T>(value);public static implicit operator StaticModInt<T>(long value)=>new StaticModInt<T>(value);public StaticModInt<T>Pow(long n){var x=this;var r=new StaticModInt<T>(1U);while(n>0){if((n&1)>0){r*=x;}x*=x;n>>=1;}return r;}[MethodImpl(AggressiveInlining)]public StaticModInt<T>Inv(){if(op.IsPrime){return Pow(op.Mod-2);}else{var(g,x)=InternalMath.InvGCD(_v,op.Mod);return new StaticModInt<T>(x);}}public override string ToString()=>_v.ToString();public override bool Equals(object obj)=>obj is StaticModInt<T>m&&Equals(m);public bool Equals(StaticModInt<T>other)=>_v==other._v;public override int GetHashCode()=>_v.GetHashCode();}}
namespace AtCoder{public interface IAdditionOperator<T>{T Add(T x,T y);T Subtract(T x,T y);}public interface IMultiplicationOperator<T>{T Multiply(T x,T y);T MultiplyIdentity{get;}}public interface IDivisionOperator<T>:IMultiplicationOperator<T>{T Divide(T x,T y);T Modulo(T x,T y);}public interface IUnaryNumOperator<T>{T Minus(T x);T Increment(T x);T Decrement(T x);}public interface IArithmeticOperator<T>:IAdditionOperator<T>,IMultiplicationOperator<T>,IDivisionOperator<T>,IUnaryNumOperator<T>{}public interface ICompareOperator<T>:IComparer<T>{bool GreaterThan(T x,T y);bool GreaterThanOrEqual(T x,T y);bool LessThan(T x,T y);bool LessThanOrEqual(T x,T y);}public interface INumOperator<T>:IArithmeticOperator<T>,ICompareOperator<T>{T MinValue{get;}T MaxValue{get;}}public interface IShiftOperator<T>{T LeftShift(T x,int y);T RightShift(T x,int y);}}
#endregion Expanded by https://github.com/kzrnm/SourceExpander".ReplaceEOL().ToLiteral()
+ @"},})},
};
}}").ReplaceEOL())
                    }
                }
            };
            await test.RunAsync();
        }
    }
}
